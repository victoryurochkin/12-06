# Домашнее задание к занятию "`«Репликация и масштабирование. Часть 1»`" - `Юрочкин В.А.`

---

### Задание 1

На лекции рассматривались режимы репликации master-slave, master-master, опишите их различия. Ответить в свободной форме.

`Ответ:`

# Режимы репликации баз данных: Master–Slave и Master–Master

На лекции рассматривались два основных режима репликации баз данных: **master–slave** и **master–master**. Ниже приведено подробное описание их различий, принципов работы, преимуществ и недостатков.

---

## Репликация master–slave

Это наиболее распространённая и простая в эксплуатации схема репликации.

### Архитектура
- **Master (ведущий сервер)**  
  Основной сервер базы данных. Все операции записи (INSERT, UPDATE, DELETE, а также DDL-запросы) выполняются только на нём.
- **Slave (ведомый сервер / серверы)**  
  Является копией мастера. Получает все изменения от master и, как правило, используется для выполнения запросов на чтение (SELECT).

### Принцип работы
1. Master записывает все изменения данных в специальный журнал — **binary log (binlog)**.
2. Slave копирует изменения из binlog мастера и сохраняет их в локальный журнал — **relay log**.
3. Slave последовательно применяет изменения из relay log, обновляя собственные данные.

### Типы репликации
- **Покомандная (statement-based replication)**  
  Реплицируются SQL-запросы.  
  Плюсы:
  - меньший объём логов  
  Минусы:
  - возможны проблемы с недетерминированными функциями (NOW(), RAND() и т.п.)

- **Построчная (row-based replication)**  
  Реплицируются изменения конкретных строк данных.  
  Плюсы:
  - более надёжная и предсказуемая  
  Минусы:
  - больший объём логов

(На практике часто используется смешанный режим — **mixed**.)

### Преимущества
- Простая настройка и администрирование
- Хорошо масштабирует операции чтения
- Чёткое разделение ролей серверов
- Практически отсутствует риск конфликтов данных

### Недостатки
- Единственная точка записи (master)
- При отказе master требуется переключение на другой сервер
- Возможна задержка репликации (replication lag)

### Типичные сценарии использования
- Веб-приложения с большим количеством операций чтения
- Формирование отчётов и аналитика
- Резервное копирование с ведомых серверов

---

## Репликация master–master

Схема с несколькими равноправными серверами.

### Архитектура
- Каждый сервер одновременно выполняет роль:
  - **Master** — принимает запросы на запись
  - **Slave** — получает изменения от других мастеров

Чаще всего используется конфигурация из двух серверов.

### Принцип работы
- Изменения, выполненные на одном сервере, записываются в его binlog
- Второй сервер реплицирует эти изменения и применяет их у себя
- Репликация является двунаправленной

### Преимущества
- Повышенная отказоустойчивость
- Возможность продолжать работу при выходе из строя одного узла
- Потенциальное распределение нагрузки на запись

### Недостатки
- Высокий риск конфликтов данных при одновременной записи
- Более сложная настройка и сопровождение
- Требует строгих правил работы с записью данных
- Необходима дополнительная логика на уровне приложения или прокси

### Типичные сценарии использования
- Системы с высокими требованиями к доступности
- Специфические HA-решения
- Проекты, где допустима повышенная архитектурная сложность

---

## Ключевые различия

| Критерий              | Master–Slave                  | Master–Master                   |
|-----------------------|-------------------------------|---------------------------------|
| Запись данных         | Только на master              | На любом узле                   |
| Чтение данных         | Обычно со slave               | С любого узла                   |
| Отказоустойчивость    | Средняя                       | Высокая                         |
| Риск конфликтов       | Минимальный                   | Высокий                         |
| Сложность реализации  | Низкая                        | Высокая                         |
| Основное применение   | Большинство продакшн-систем   | Специфические HA-сценарии       |

---

## Вывод

- **Master–slave** — наиболее универсальная и широко применяемая схема репликации, подходящая для большинства проектов.
- **Master–master** — используется в особых случаях, где критична отказоустойчивость и допустима повышенная сложность системы.

---

### Задание 2

Выполните конфигурацию master-slave репликации, примером можно пользоваться из лекции.

Приложите скриншоты конфигурации, выполнения работы: состояния и режимы работы серверов.

`Ответ:`

Шаг 0. Подготовка системы (на ОБЕИХ ВМ)

```
sudo apt update
sudo apt install -y mysql-server
```

проверка:

```
mysql --version
systemctl status mysql
```

<img width="1258" height="416" alt="image" src="https://github.com/user-attachments/assets/e2028fa6-1778-4353-8df1-3714ef1c3a8c" />


<img width="1250" height="416" alt="image" src="https://github.com/user-attachments/assets/f1aba403-9d0f-4f5a-bab9-7a12685632f7" />



Шаг 1. Настройка MASTER
1.1 Задать server-id и включить binlog

Открываем конфиг:

```
sudo nano /etc/mysql/mysql.conf.d/mysqld.cnf
```

Добавляем:

```
server-id = 1
log-bin = mysql-bin
binlog_format = ROW
```

перезапуск:

```
sudo systemctl restart mysql
```

1.2 Создать пользователя репликации

```
sudo mysql
```

```
CREATE USER 'repl'@'%' IDENTIFIED WITH mysql_native_password BY 'replpass';
GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%';
FLUSH PRIVILEGES;
EXIT;
```

1.3 Получить координаты binlog

```
sudo mysql -e "SHOW MASTER STATUS\G"
```
<img width="998" height="758" alt="image" src="https://github.com/user-attachments/assets/74336c39-0491-48d3-b576-18dd3e87d429" />


2. Настройка конфигурации SLAVE

Открываем конфиг:

```
sudo nano /etc/mysql/mysql.conf.d/mysqld.cnf
```

Добавляем:

```
server-id = 2
relay-log = mysql-relay-bin
read_only = ON
```

Перезапускаем службу:

```
sudo systemctl restart mysql
```

3. Подключаем slave к master

Заходим в MySQL:

```
sudo mysql
```

```
CHANGE MASTER TO
MASTER_HOST='192.168.1.64',
MASTER_USER='repl',
MASTER_PASSWORD='replpass',
MASTER_LOG_FILE='mysql-bin.000001',
MASTER_LOG_POS=827;

START SLAVE;
```

4. Проверяем статус репликации

```
SHOW SLAVE STATUS\G
```

<img width="1366" height="956" alt="image" src="https://github.com/user-attachments/assets/5a0b02cb-f234-4045-9815-9b62d31874bd" />


5. Проверка репликации (контрольная)
На MASTER

```
sudo mysql
```

```
CREATE DATABASE repl_test;
USE repl_test;

CREATE TABLE test (
    id INT AUTO_INCREMENT PRIMARY KEY,
    msg VARCHAR(50)
);

INSERT INTO test (msg) VALUES ('replication works');
EXIT;
```

На SLAVE

```
sudo mysql
```

```
USE repl_test;
SELECT * FROM test;
```

(если порты закрыты фаерволом - нужно открыть)

<img width="955" height="957" alt="image" src="https://github.com/user-attachments/assets/e9123980-e2ba-4b40-b4ce-9eb751b18cec" />


<img width="1066" height="963" alt="image" src="https://github.com/user-attachments/assets/245b6741-4487-41be-b5fd-21728e3f98bd" />

`вывод:`

### Конфигурация master-сервера
- Включён бинарный лог (log-bin)
- Задан уникальный server-id
- Создан пользователь репликации с правами REPLICATION SLAVE
- Получены координаты бинарного лога (File и Position)

### Конфигурация slave-сервера
- Задан уникальный server-id
- Включён режим read-only
- Настроено подключение к master с помощью команды CHANGE MASTER TO
- Репликация запущена командой START SLAVE

### Проверка работы
Состояние репликации проверено командой SHOW SLAVE STATUS.
Потоки Slave_IO_Running и Slave_SQL_Running находятся в состоянии Yes,
задержка репликации отсутствует.

Для проверки были созданы база данных и таблица на master-сервере,
а также выполнены операции INSERT. Данные автоматически появились
на slave-сервере, что подтверждает корректную работу репликации.

### Вывод
Репликация MySQL master–slave настроена и функционирует корректно.



